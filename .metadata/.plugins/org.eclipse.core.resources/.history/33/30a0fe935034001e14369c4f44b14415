#include "http.h"

/*   http Response parser 

func1 = Extract Status Code 
func2 = Extract Content Length
func3 = Extract Content Type
func4 = Extract Body
func 5 = Main Function To Parse Response 

*/
uint16_t HTTP_RES_extract_Status_Code(const uint8_t *response) {
    // Find the space after "HTTP/1.1"
    const char *statusCodeStart = strstr(response, " ") + 1;
    
    // Find the space after the status code
    const char *statusCodeEnd = strstr(statusCodeStart, " ");
    
    // Calculate the length of the status code
    int statusCodeLength = statusCodeEnd - statusCodeStart;
    
    // Convert the status code string to an integer
    char statusCodeString[4]; // Maximum 3 digits for the status code (+1 for null terminator)
    strncpy(statusCodeString, statusCodeStart, statusCodeLength);
    statusCodeString[statusCodeLength] = '\0';
    int statusCode = atoi(statusCodeString);
    
    return statusCode;
}
//----------------------------------------------------------------------------------------------------------------
uint32_t HTTP_RES_extract_Content_Length(const uint8_t *response) {
    const char *lengthStart = strstr(response, "Content-Length: ");
    
    if (lengthStart == NULL) {
        printf("Content-Length not found in the response.\n");
        return -1;
    }
    
    // Move the pointer to the start of the content length value (after "Content-Length: ")
    lengthStart += strlen("Content-Length: ");
    
    // Extract the content length as an integer
    int contentLength = 0;
    while (*lengthStart >= '0' && *lengthStart <= '9') {
        contentLength = contentLength * 10 + (*lengthStart - '0');
        lengthStart++;
    }
    
    return contentLength;
}
//-----------------------------------------------------------------------------------------------------------------
uint8_t HTTP_RES_extract_Content_Type(const uint8_t  * response) {
   static char contentType[MAX_BUF_SIZE]; // Fixed-size buffer
   const char * typeStart = strstr(response, "Content-Type: ");

   if (typeStart == NULL) {
      printf("Content-Type not found in the response.\n");
      return NULL;
   }

   // Move the pointer to the start of the content type value (after "Content-Type: ")
   typeStart += strlen("Content-Type: ");

   // Find the end of the content type value (usually ends with a newline character)
   const char * typeEnd = strchr(typeStart, '\n');

   // Calculate the length of the content type value (up to the maximum size of the buffer)
   uint16_t typeLength = typeEnd - typeStart;
   // Copy the content type value to the buffer
   memcpy(contentType, typeStart, typeLength);

   // Null-terminate the content type string
   contentType[typeLength] = '\0';

   // Check the content type and set RES.TYPE accordingly
   if (strstr(contentType, "text/html") || strstr(contentType, "text/HTML")) {
      return  PTYPE_HTML;
   } else if (strstr(contentType, "text/css") || strstr(contentType, "text/CSS")) {
      return PTYPE_CSS;
   } else if (strstr(contentType, "application/javascript")) {
      return PTYPE_JS;
   } else if (strstr(contentType, "application/json")) {
      return PTYPE_JSON;
   } else if (strstr(contentType, "application/xml") || strstr(contentType, "text/xml")) {
      return PTYPE_XML;
   } else if (strstr(contentType, "text/plain")) {
      return PTYPE_TEXT;
   } else if (strstr(contentType, "application/x-cgi")) {
      return PTYPE_CGI;
   } else if (strstr(contentType, "application/x-shockwave-flash")) {
      return PTYPE_FLASH;
   } else {
      // If the content type is not recognized, set it to PTYPE_ERR (Error)
    return PTYPE_ERR;
   }

}
//-----------------------------------------------------------------------------------------------------------------
uint8_t* HTTP_RES_extract_Body(const uint8_t  * response){
    static char body[MAX_BUF_SIZE];
    const char *bodyStart = strstr(response, "\r\n\r\n");
    if (bodyStart == NULL) {
        // Handle body not found appropriately
        return NULL;
    }
    
    // Move the pointer to the start of the body (after the \r\n\r\n sequence)
    bodyStart += 4;
    
    // Calculate the length of the body
    uint16_t bodyLength = (uint16_t)strlen(bodyStart);
    
    // Copy the body content to the buffer
    memcpy(body, bodyStart, bodyLength);
    
    // Null-terminate the body string
    body[bodyLength] = '\0';
    
    return body;
}
//------------------------------------------------------------------------------------------------------------------
uint8_t HTTP_RES_parse(const uint8_t *response, st_http_response *RES)
{
   RES->STATUS = HTTP_RES_extract_Status_Code(response);
   RES->CONT_LEN = HTTP_RES_extract_Content_Length(response);
	RES->TYPE = HTTP_RES_extract_Content_Type(response);
	RES->BODY = HTTP_RES_extract_Body(response); 
}
//------------------------------------------------------------------------------------------------------------------
int main() {
    const char *response = "HTTP/1.1 400 Bad Request\r\n"
                           "Content-Type: application/json\r\n"
                           "Content-Length: 68\r\n"
                           "\r\n"
                           "{\r\n"
                           "  \"erdffffffffffffffffffffror\": \"Invalid input\",\r\n"
                           "  \"message\": \"The 'age' field must be a positive integer.\"\r\n"
                           "}";

    st_http_response RES; // Assuming you have declared an instance of the struct

    HTTP_RES_parse(response, &RES);
    printf("Statuse = %d\n",RES.STATUS);
    printf("Content-Length = %d\n",RES.CONT_LEN);
    printf("Content_Type = %d\n",RES.TYPE);
    printf("Body = %s\n",RES.BODY);
    return 0;
}
//------------------------------------------------------------------------------------------------------------------